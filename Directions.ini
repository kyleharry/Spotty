USER INFO:
	•	Comfortable enough in a terminal to follow commands, not interested in yak shaving.
	•	Using Antigravity as their IDE.
	•	Don’t really want to learn “proper GitHub” beyond what’s needed to host a static app.
	•	ADHD brain => wants chunked, sequential tasks, each with a clear “done” state.

⸻

0. Reality check: Recommendations API may be blocked for you

As of Nov 27, 2024, Spotify announced that new Web API use cases can no longer use several recommendation-related endpoints, including:
	•	/v1/recommendations
	•	audio features / audio analysis
	•	related artists
	•	some curated playlist endpoints

Existing apps with “extended mode” access can keep using them, but new apps often see 404 or similar when calling /v1/recommendations.

So:
	•	Plan for recommendations to possibly not work.
	•	Design the app so it still works as a manual “set → playlist” tool.
	•	Add a “best effort” call to /v1/recommendations with clear error handling:
if it fails, you show “Spotify has disabled recommendations for new apps; here’s your base playlist instead.”

I’ll still show you how to wire /v1/recommendations, but treat it as “nice if Spotify allows it, harmless if they don’t.”

⸻

1. Project overview

You’re building a static web app (no backend) that:
	1.	Runs on GitHub Pages at a URL like
https://kyleharry.github.io/spotify-set-builder/
	2.	Uses Authorization Code with PKCE in the browser to get a user access token. This is what Spotify recommends for a SPA where you can’t hide a client secret.
	3.	Lets you:
	•	Paste or drag Spotify tracks onto the page to build a “set”.
	•	Click a button to:
	•	Option A: Create a playlist from the set only.
	•	Option B: Try to call /v1/recommendations using the set as seeds, fold those into the playlist, then create it.
	4.	Opens the resulting playlist in Spotify.

Files you’ll need:
	•	index.html – main UI + JS
	•	auth.js (optional separation) – PKCE auth helpers
	•	README.md – just to remind Future Kyle how this thing works

You can keep it to one HTML file with inline JS if you want, but separate files are easier to think about.

⸻

2. Phase 1 – Spotify app setup
	1.	Go to the Spotify Developer Dashboard.
	2.	Create a new app.
	3.	In the app settings, note:
	•	Client ID
	•	(You will not use the client secret in the browser for PKCE.)
	4.	Under Redirect URIs, add:

https://YOUR_GITHUB_USERNAME.github.io/spotify-set-builder/callback.html

Or, if you want to reuse index.html as callback:

https://YOUR_GITHUB_USERNAME.github.io/spotify-set-builder/

It must be HTTPS and must match exactly what you’ll use as redirect_uri in your code.

	5.	Save.

Scopes you’ll eventually request:
	•	playlist-modify-private
	•	playlist-modify-public (if you want public playlists)

⸻

3. Phase 2 – GitHub repo + Pages via Antigravity

3.1 Local project in Antigravity

In Antigravity:
	1.	Create a folder on disk, e.g. spotify-set-builder.
	2.	In Antigravity, Open Folder… → choose that folder.
	3.	Create these files:
	•	index.html – leave it as a minimal HTML stub for now.
	•	callback.html – can initially be a copy of index.html or a simple page that loads the same JS.

3.2 Initialize Git and connect to GitHub

In Antigravity:
	1.	Open the Source Control panel (branch/Y icon).
	2.	Click Initialize Repository.
	3.	Stage all files, commit with message Initial commit.

Now connect to GitHub:
	1.	On the GitHub website:
	•	Create a new repo named spotify-set-builder (no template).
	2.	Back in Antigravity, open the integrated terminal and run:

git remote add origin https://github.com/kyleharry/spotify-set-builder.git
git branch -M main
git push -u origin main



3.3 Turn on GitHub Pages

On GitHub:
	1.	Go to your repo → Settings → Pages.
	2.	Under “Build and deployment”:
	•	Source: Deploy from a branch
	•	Branch: main / root (/)
	3.	Save.

After a minute or two you should get a URL like:

https://kyleharry.github.io/spotify-set-builder/

Bookmark it. That’s your live app.

Every time you change files and run:

git add .
git commit -m "something"
git push

GitHub Pages redeploys.

⸻

4. Phase 3 – Spotify auth (Authorization Code with PKCE)

You’re writing a SPA. Spotify says: use Authorization Code with PKCE.

The flow in your app:
	1.	Generate:
	•	a random code_verifier
	•	a code_challenge = BASE64URL(SHA256(code_verifier))
	2.	Redirect user to:

https://accounts.spotify.com/authorize
  ?client_id=YOUR_CLIENT_ID
  &response_type=code
  &redirect_uri=YOUR_CALLBACK_URL
  &scope=playlist-modify-private%20playlist-modify-public
  &code_challenge=CODE_CHALLENGE
  &code_challenge_method=S256


	3.	User logs in, approves.
	4.	Spotify redirects to redirect_uri?code=...&state=...
	5.	On callback.html, you:
	•	Grab the code from the URL.
	•	POST to https://accounts.spotify.com/api/token with:
	•	grant_type=authorization_code
	•	client_id
	•	code
	•	redirect_uri
	•	code_verifier
	6.	Response gives you access_token (and refresh_token if allowed).
	7.	Store access_token in memory or sessionStorage and redirect back to index.html with some marker (or just keep everything on one page and handle both states).

Spotify’s official PKCE tutorial walks through the same steps.

Implementation tips given your patience level:
	•	Put all auth helpers in one JS file (auth.js) with functions like:
	•	startAuth()
	•	handleRedirectCallback()
	•	getAccessToken()
	•	Store code_verifier in sessionStorage before redirecting to Spotify; read it back on the callback.

You do not use the client secret in this flow on the front end. The PKCE extension is explicitly there so you don’t need it.

⸻

5. Phase 4 – UI + “set” builder (index.html)

High-level UI pieces:
	1.	Header:
	•	Title.
	•	Small “You’re logged in as X” / “Connect Spotify” indicator.
	2.	Auth:
	•	“Connect / Reconnect to Spotify” button → calls startAuth().
	3.	Drop zone:
	•	A large box: “Drop Spotify tracks here.”
	•	Handle dragover / drop.
	•	Parse event.dataTransfer.getData('text/uri-list') and text/plain for:
	•	https://open.spotify.com/track/{id}
	•	spotify:track:{id}
	4.	Track list:
	•	Show each selected track:
	•	Name, primary artist.
	•	Remove button.
	5.	Options:
	•	Toggle: “Use recommendations to expand playlist (if available) [ ]”.
	•	Number input for “how many recommended tracks to add” (e.g. 20).
	6.	Actions:
	•	Playlist name input.
	•	“Create playlist” button.

Data model in JS:

let accessToken = null;

let trackSet = [
  {
    id: 'track_id',
    uri: 'spotify:track:track_id',
    name: 'Song Title',
    artist: 'Artist Name'
  },
  // ...
];

Track flow:
	•	On drop:
	•	Extract track IDs, de-duplicate against trackSet.
	•	For newly added IDs, call GET https://api.spotify.com/v1/tracks?ids=... using your access_token.
	•	Populate name and artist from those responses.
	•	Update the DOM.

Persist trackSet in localStorage so your “set” survives refresh.

⸻

6. Phase 5 – Recommendations (with deprecation-aware behavior)

Intended behavior:
	•	If “Use recommendations” is enabled:
	•	Use up to 5 of your set tracks as seeds (Spotify’s limit is 5 seed items).
	•	Call /v1/recommendations with seed_tracks and limit.
	•	Add any returned track URIs to the playlist payload.

The catch: As discussed, /v1/recommendations is deprecated for new use cases; many new apps now see 404 or similar.

So, your logic should be:

async function fetchRecommendationsIfAllowed(seedTrackIds, limit) {
  if (!seedTrackIds.length) return [];

  const params = new URLSearchParams({
    seed_tracks: seedTrackIds.slice(0, 5).join(','),
    limit: String(limit || 20)
  });

  const res = await fetch(
    'https://api.spotify.com/v1/recommendations?' + params.toString(),
    {
      headers: { Authorization: 'Bearer ' + accessToken }
    }
  );

  if (!res.ok) {
    // Log it, show a gentle message, and just fall back.
    if (res.status === 404 || res.status === 403) {
      showStatus(
        'Spotify has disabled recommendations for this app. Generating a playlist from your selected tracks only.'
      );
      return [];
    }
    showStatus('Error calling recommendations endpoint. Using base set only.');
    return [];
  }

  const data = await res.json();
  return (data.tracks || []).map(t => ({
    id: t.id,
    uri: t.uri,
    name: t.name,
    artist: t.artists?.[0]?.name || ''
  }));
}

Then, when building the playlist:
	•	Always include your base trackSet URIs.
	•	Optionally append the URIs from fetchRecommendationsIfAllowed.

If Spotify has closed the door for you, you still get a working app; you just lose the discovery layer.

⸻

7. Phase 6 – Creating the playlist and opening it

Playlist creation flow with the Web API:
	1.	Get current user:

GET https://api.spotify.com/v1/me
Authorization: Bearer ACCESS_TOKEN

Response has id (the user ID).

	2.	Create playlist:

POST https://api.spotify.com/v1/users/{user_id}/playlists
Authorization: Bearer ACCESS_TOKEN
Content-Type: application/json

{
  "name": "My Set Radio-ish",
  "description": "Built by my set-builder tool",
  "public": false
}


	3.	Add tracks:

POST https://api.spotify.com/v1/playlists/{playlist_id}/tracks
Authorization: Bearer ACCESS_TOKEN
Content-Type: application/json

{
  "uris": ["spotify:track:...", ...]
}

If you have more than 100 URIs, send them in batches.

	4.	Open playlist in new tab:

window.open(
  'https://open.spotify.com/playlist/' + playlistId,
  '_blank'
);



That gives you a playlist that’s effectively “your set ± recommendations.” You can call it “radio” in your UI, but under the hood it’s just a static playlist.

⸻

8. Phase 7 – How you will actually use this

Once it’s built:
	1.	Go to your GitHub Pages URL in a browser.
	2.	Click “Connect to Spotify” → run PKCE auth → land back on your app with access_token ready.
	3.	In Spotify (desktop or web):
	•	Drag tracks or albums; drop them in your app’s drop zone.
	4.	Optional: tick “Use recommendations” and set a number of extra tracks.
	5.	Set playlist name, click “Create playlist”.
	6.	Your app:
	•	Creates playlist.
	•	Tries recommendations (if Spotify still allows your app).
	•	Adds tracks.
	•	Opens playlist in Spotify.

If recommendations are blocked, you’ll just see the base playlist. You’ll know why, because you coded the message.

⸻

9. What you should actually do next

Given where you are:
	•	Don’t implement everything at once. Go in this order:
	1.	GitHub Pages + “hello world” index.html.
	2.	PKCE auth end-to-end: just get access_token and log it in the console.
	3.	Basic /me call to prove auth is solid.
	4.	Drag-and-drop parsing + /v1/tracks fetch.
	5.	Playlist creation from trackSet only.
	6.	Finally, layer in /v1/recommendations with the defensive error handling.

Each step is independent enough that you can stop for the night and still have something that works.

If you want, next turn I can give you a concrete index.html skeleton wired for PKCE + set builder, tailored to GitHub Pages, so you can more or less paste and then tweak.